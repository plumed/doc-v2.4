<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
<meta name="robots" content="noindex">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - plumed test coverage - isdb/Rescale.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">isdb</a> - Rescale.cpp<span style="font-size: 80%;"> (source / <a href="Rescale.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">plumed test coverage</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntry">190</td>
            <td class="headerCovTableEntryLo">12.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-11-18 11:20:57</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryLo">29.4 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</a>
<span class="lineNum">       2 </span>            :    Copyright (c) 2017-2019 The plumed team
<span class="lineNum">       3 </span>            :    (see the PEOPLE file at the root of the distribution for a list of names)
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            :    See http://www.plumed.org for more information.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            :    This file is part of plumed, version 2.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :    plumed is free software: you can redistribute it and/or modify
<span class="lineNum">      10 </span>            :    it under the terms of the GNU Lesser General Public License as published by
<span class="lineNum">      11 </span>            :    the Free Software Foundation, either version 3 of the License, or
<span class="lineNum">      12 </span>            :    (at your option) any later version.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            :    plumed is distributed in the hope that it will be useful,
<span class="lineNum">      15 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      16 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      17 </span>            :    GNU Lesser General Public License for more details.
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            :    You should have received a copy of the GNU Lesser General Public License
<span class="lineNum">      20 </span>            :    along with plumed.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
<span class="lineNum">      21 </span>            : +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
<span class="lineNum">      22 </span>            : /*
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : */
<span class="lineNum">      25 </span>            : #include &quot;bias/Bias.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;bias/ActionRegister.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;core/PlumedMain.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;core/Atoms.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;core/Value.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;tools/File.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;tools/Random.h&quot;
<span class="lineNum">      32 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      33 </span>            : #include &lt;ctime&gt;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : using namespace std;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : namespace PLMD {
<span class="lineNum">      38 </span>            : namespace isdb {
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : //+PLUMEDOC ISDB_BIAS RESCALE
<span class="lineNum">      41 </span>            : /*
<span class="lineNum">      42 </span>            : Rescales the value of an another action, being a Collective Variable or a Bias.
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : The rescaling factor is determined by a parameter defined on a logarithmic grid of dimension NBIN in the range
<span class="lineNum">      45 </span>            : from 1 to MAX_RESCALE. The current value of the rescaling parameter is stored and shared across
<span class="lineNum">      46 </span>            : other actions using a \ref SELECTOR. A Monte Carlo procedure is used to update the value
<span class="lineNum">      47 </span>            : of the rescaling factor every MC_STRIDE steps of molecular dynamics. Well-tempered metadynamics, defined by the
<span class="lineNum">      48 </span>            : parameters W0 and BIASFACTOR, is used to enhance the sampling in the space of the rescaling factor.
<span class="lineNum">      49 </span>            : The well-tempered metadynamics bias potential is written to the file BFILE every BSTRIDE steps and read
<span class="lineNum">      50 </span>            : when restarting the simulation using the directive \ref RESTART.
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : \note
<span class="lineNum">      53 </span>            : Additional arguments not to be rescaled, one for each bin in the rescaling parameter ladder, can be
<span class="lineNum">      54 </span>            : provided at the end of the ARG list. The number of such arguments is specified by the option NOT_RESCALED.
<span class="lineNum">      55 </span>            : These arguments will be not be rescaled, but they will be
<span class="lineNum">      56 </span>            : considered as bias potentials and used in the computation of the Metropolis
<span class="lineNum">      57 </span>            : acceptance probability when proposing a move in the rescaling parameter. See example below.
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : \note
<span class="lineNum">      60 </span>            : If PLUMED is running in a multiple-replica framework (for example using the -multi option in GROMACS),
<span class="lineNum">      61 </span>            : the arguments will be summed across replicas, unless the NOT_SHARED option is used. Also, the value of the
<span class="lineNum">      62 </span>            : \ref SELECTOR will be shared and thus will be the same in all replicas.
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : \par Examples
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : In this example we use \ref RESCALE to implement a simulated-tempering like approach.
<span class="lineNum">      67 </span>            : The total potential energy of the system is rescaled by a parameter defined on a logarithmic grid
<span class="lineNum">      68 </span>            : of 5 bins in the range from 1 to 1.5.
<span class="lineNum">      69 </span>            : A well-tempered metadynamics bias potential is used to ensure diffusion in the space of the rescaling
<span class="lineNum">      70 </span>            : parameter.
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : \plumedfile
<span class="lineNum">      73 </span>            : ene: ENERGY
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : SELECTOR NAME=GAMMA VALUE=0
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : RESCALE ...
<span class="lineNum">      78 </span>            : LABEL=res ARG=ene TEMP=300
<span class="lineNum">      79 </span>            : SELECTOR=GAMMA MAX_RESCALE=1.5 NBIN=5
<span class="lineNum">      80 </span>            : W0=1000 BIASFACTOR=100.0 BSTRIDE=2000 BFILE=bias.dat
<span class="lineNum">      81 </span>            : ...
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : PRINT FILE=COLVAR ARG=* STRIDE=100
<span class="lineNum">      84 </span>            : \endplumedfile
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : In this second example, we add to the simulated-tempering approach introduced above
<span class="lineNum">      87 </span>            : one Parallel Bias metadynamics simulation (see \ref PBMETAD) for each value of the rescaling parameter.
<span class="lineNum">      88 </span>            : At each moment of the simulation, only one of the \ref PBMETAD
<span class="lineNum">      89 </span>            : actions is activated, based on the current value of the associated \ref SELECTOR.
<span class="lineNum">      90 </span>            : The \ref PBMETAD bias potentials are not rescaled, but just used in the calculation of
<span class="lineNum">      91 </span>            : the Metropolis acceptance probability when proposing a move in the rescaling parameter.
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : \plumedfile
<span class="lineNum">      94 </span>            : ene: ENERGY
<span class="lineNum">      95 </span>            : d: DISTANCE ATOMS=1,2
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : SELECTOR NAME=GAMMA VALUE=0
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : pbmetad0: PBMETAD ARG=d SELECTOR=GAMMA SELECTOR_ID=0 SIGMA=0.1 PACE=500 HEIGHT=1 BIASFACTOR=8 FILE=HILLS.0
<span class="lineNum">     100 </span>            : pbmetad1: PBMETAD ARG=d SELECTOR=GAMMA SELECTOR_ID=1 SIGMA=0.1 PACE=500 HEIGHT=1 BIASFACTOR=8 FILE=HILLS.1
<span class="lineNum">     101 </span>            : pbmetad2: PBMETAD ARG=d SELECTOR=GAMMA SELECTOR_ID=2 SIGMA=0.1 PACE=500 HEIGHT=1 BIASFACTOR=8 FILE=HILLS.2
<span class="lineNum">     102 </span>            : pbmetad3: PBMETAD ARG=d SELECTOR=GAMMA SELECTOR_ID=3 SIGMA=0.1 PACE=500 HEIGHT=1 BIASFACTOR=8 FILE=HILLS.3
<span class="lineNum">     103 </span>            : pbmetad4: PBMETAD ARG=d SELECTOR=GAMMA SELECTOR_ID=4 SIGMA=0.1 PACE=500 HEIGHT=1 BIASFACTOR=8 FILE=HILLS.4
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : RESCALE ...
<span class="lineNum">     106 </span>            : LABEL=res TEMP=300
<span class="lineNum">     107 </span>            : ARG=ene,pbmetad0.bias,pbmetad1.bias,pbmetad2.bias,pbmetad3.bias,pbmetad4.bias
<span class="lineNum">     108 </span>            : SELECTOR=GAMMA MAX_RESCALE=1.5 NOT_RESCALED=5 NBIN=5
<span class="lineNum">     109 </span>            : W0=1000 BIASFACTOR=100.0 BSTRIDE=2000 BFILE=bias.dat
<span class="lineNum">     110 </span>            : ...
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : PRINT FILE=COLVAR ARG=* STRIDE=100
<span class="lineNum">     113 </span>            : \endplumedfile
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : */
<span class="lineNum">     118 </span>            : //+ENDPLUMEDOC
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : class Rescale : public bias::Bias
<span class="lineNum">     121 </span>            : {
<span class="lineNum">     122 </span>            :   // gamma parameter
<span class="lineNum">     123 </span>            :   vector&lt;double&gt; gamma_;
<span class="lineNum">     124 </span>            :   double         w0_;
<span class="lineNum">     125 </span>            :   double         biasf_;
<span class="lineNum">     126 </span>            :   vector&lt;double&gt; bias_;
<span class="lineNum">     127 </span>            :   vector&lt;double&gt; expo_;
<span class="lineNum">     128 </span>            :   vector&lt;unsigned&gt; shared_;
<span class="lineNum">     129 </span>            :   unsigned nores_;
<span class="lineNum">     130 </span>            :   // bias
<span class="lineNum">     131 </span>            :   unsigned int   Biasstride_;
<span class="lineNum">     132 </span>            :   unsigned int   Biaspace_;
<span class="lineNum">     133 </span>            :   string         Biasfilename_;
<span class="lineNum">     134 </span>            :   bool           first_bias_;
<span class="lineNum">     135 </span>            :   OFile          Biasfile_;
<span class="lineNum">     136 </span>            :   // temperature in kbt
<span class="lineNum">     137 </span>            :   double kbt_;
<span class="lineNum">     138 </span>            :   // Monte Carlo stuff
<span class="lineNum">     139 </span>            :   unsigned MCsteps_;
<span class="lineNum">     140 </span>            :   unsigned MCstride_;
<span class="lineNum">     141 </span>            :   long int MCfirst_;
<span class="lineNum">     142 </span>            :   long unsigned MCaccgamma_;
<span class="lineNum">     143 </span>            :   // replica stuff
<span class="lineNum">     144 </span>            :   unsigned nrep_;
<span class="lineNum">     145 </span>            :   unsigned replica_;
<span class="lineNum">     146 </span>            :   // selector
<span class="lineNum">     147 </span>            :   string selector_;
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :   // Monte Carlo
<span class="lineNum">     150 </span>            :   void doMonteCarlo(unsigned igamma, double oldE, vector&lt;double&gt; args, vector&lt;double&gt; bargs);
<span class="lineNum">     151 </span>            :   unsigned proposeMove(unsigned x, unsigned xmin, unsigned xmax);
<span class="lineNum">     152 </span>            :   bool doAccept(double oldE, double newE);
<span class="lineNum">     153 </span>            :   // read and print bias
<span class="lineNum">     154 </span>            :   void read_bias();
<span class="lineNum">     155 </span>            :   void print_bias(long int step);
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : public:
<span class="lineNum">     158 </span>            :   explicit Rescale(const ActionOptions&amp;);
<span class="lineNum">     159 </span>            :   ~Rescale();
<span class="lineNum">     160 </span>            :   void calculate();
<span class="lineNum">     161 </span>            :   static void registerKeywords(Keywords&amp; keys);
<span class="lineNum">     162 </span>            : };
<a name="163"><span class="lineNum">     163 </span>            : </a>
<span class="lineNum">     164 </span>            : 
<a name="165"><span class="lineNum">     165 </span><span class="lineCov">       6452 : PLUMED_REGISTER_ACTION(Rescale,&quot;RESCALE&quot;)</span></a>
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span><span class="lineCov">          1 : void Rescale::registerKeywords(Keywords&amp; keys) {</span>
<span class="lineNum">     168 </span><span class="lineCov">          1 :   Bias::registerKeywords(keys);</span>
<span class="lineNum">     169 </span><span class="lineCov">          2 :   keys.use(&quot;ARG&quot;);</span>
<span class="lineNum">     170 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;TEMP&quot;,&quot;temperature&quot;);</span>
<span class="lineNum">     171 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;SELECTOR&quot;, &quot;name of the SELECTOR used for rescaling&quot;);</span>
<span class="lineNum">     172 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;MAX_RESCALE&quot;,&quot;maximum values for rescaling&quot;);</span>
<span class="lineNum">     173 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;NBIN&quot;,&quot;number of bins for gamma grid&quot;);</span>
<span class="lineNum">     174 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;W0&quot;, &quot;initial bias height&quot;);</span>
<span class="lineNum">     175 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;BIASFACTOR&quot;, &quot;bias factor&quot;);</span>
<span class="lineNum">     176 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;BSTRIDE&quot;, &quot;stride for writing bias&quot;);</span>
<span class="lineNum">     177 </span><span class="lineCov">          4 :   keys.add(&quot;compulsory&quot;,&quot;BFILE&quot;, &quot;file name for bias&quot;);</span>
<span class="lineNum">     178 </span><span class="lineCov">          4 :   keys.add(&quot;optional&quot;,&quot;NOT_SHARED&quot;,   &quot;list of arguments (from 1 to N) not summed across replicas&quot;);</span>
<span class="lineNum">     179 </span><span class="lineCov">          4 :   keys.add(&quot;optional&quot;,&quot;NOT_RESCALED&quot;, &quot;these last N arguments will not be rescaled&quot;);</span>
<span class="lineNum">     180 </span><span class="lineCov">          4 :   keys.add(&quot;optional&quot;,&quot;MC_STEPS&quot;,&quot;number of MC steps&quot;);</span>
<span class="lineNum">     181 </span><span class="lineCov">          4 :   keys.add(&quot;optional&quot;,&quot;MC_STRIDE&quot;,&quot;MC stride&quot;);</span>
<span class="lineNum">     182 </span><span class="lineCov">          4 :   keys.add(&quot;optional&quot;,&quot;PACE&quot;, &quot;Pace for adding bias, in MC stride unit&quot;);</span>
<span class="lineNum">     183 </span><span class="lineCov">          1 :   componentsAreNotOptional(keys);</span>
<span class="lineNum">     184 </span><span class="lineCov">          4 :   keys.addOutputComponent(&quot;igamma&quot;,  &quot;default&quot;,&quot;gamma parameter&quot;);</span>
<span class="lineNum">     185 </span><span class="lineCov">          4 :   keys.addOutputComponent(&quot;accgamma&quot;,&quot;default&quot;,&quot;MC acceptance for gamma&quot;);</span>
<span class="lineNum">     186 </span><span class="lineCov">          4 :   keys.addOutputComponent(&quot;wtbias&quot;,  &quot;default&quot;,&quot;well-tempered bias&quot;);</span>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineNoCov">          0 : Rescale::Rescale(const ActionOptions&amp;ao):</span>
<span class="lineNum">     190 </span>            :   PLUMED_BIAS_INIT(ao),
<span class="lineNum">     191 </span>            :   nores_(0), Biaspace_(1), first_bias_(true),
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   MCsteps_(1), MCstride_(1), MCfirst_(-1), MCaccgamma_(0)</span>
<span class="lineNum">     193 </span>            : {
<span class="lineNum">     194 </span>            :   // set up replica stuff
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :   if(comm.Get_rank()==0) {</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     nrep_    = multi_sim_comm.Get_size();</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     replica_ = multi_sim_comm.Get_rank();</span>
<span class="lineNum">     198 </span>            :   } else {
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     nrep_    = 0;</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     replica_ = 0;</span>
<span class="lineNum">     201 </span>            :   }
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   comm.Sum(&amp;nrep_,1);</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   comm.Sum(&amp;replica_,1);</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :   // wt-parameters
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   parse(&quot;W0&quot;, w0_);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   parse(&quot;BIASFACTOR&quot;, biasf_);</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   // selector name
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :   parse(&quot;SELECTOR&quot;, selector_);</span>
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :   // number of bins for gamma ladder
<span class="lineNum">     213 </span>            :   unsigned nbin;
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :   parse(&quot;NBIN&quot;, nbin);</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :   // number of bias
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :   parse(&quot;NOT_RESCALED&quot;, nores_);</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   if(nores_&gt;0 &amp;&amp; nores_!=nbin) error(&quot;The number of non rescaled arguments must be equal to either 0 or the number of bins&quot;);</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :   // maximum value of rescale
<span class="lineNum">     221 </span>            :   vector&lt;double&gt; max_rescale;
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   parseVector(&quot;MAX_RESCALE&quot;, max_rescale);</span>
<span class="lineNum">     223 </span>            :   // check dimension of max_rescale
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :   if(max_rescale.size()!=(getNumberOfArguments()-nores_))</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :     error(&quot;Size of MAX_RESCALE array must be equal to the number of arguments that will to be rescaled&quot;);</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   // calculate exponents
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   double igamma_max = static_cast&lt;double&gt;(nbin);</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;max_rescale.size(); ++i)</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     expo_.push_back(std::log(max_rescale[i])/std::log(igamma_max));</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   // allocate gamma grid and set bias to zero
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;nbin; ++i) {</span>
<span class="lineNum">     234 </span>            :     // bias grid
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     bias_.push_back(0.0);</span>
<span class="lineNum">     236 </span>            :     // gamma ladder
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     double gamma = exp( static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(nbin-1) * std::log(igamma_max) );</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :     gamma_.push_back(gamma);</span>
<span class="lineNum">     239 </span>            :   }
<span class="lineNum">     240 </span>            :   // print bias to file
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :   parse(&quot;BSTRIDE&quot;, Biasstride_);</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :   parse(&quot;BFILE&quot;,   Biasfilename_);</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :   // create vectors of shared arguments
<span class="lineNum">     245 </span>            :   // by default they are all shared
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;getNumberOfArguments(); ++i) shared_.push_back(1);</span>
<span class="lineNum">     247 </span>            :   // share across replicas or not
<span class="lineNum">     248 </span>            :   vector&lt;unsigned&gt; not_shared;
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :   parseVector(&quot;NOT_SHARED&quot;, not_shared);</span>
<span class="lineNum">     250 </span>            :   // and change the non-shared
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;not_shared.size(); ++i) {</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :     if((not_shared[i]-1)&gt;=(getNumberOfArguments()-nores_) &amp;&amp; nrep_&gt;1)</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :       error(&quot;NOT_RESCALED args must always be shared when using multiple replicas&quot;);</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :     if((not_shared[i]-1)&gt;=getNumberOfArguments())</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :       error(&quot;NOT_SHARED args should be lower than total number of arguments&quot;);</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :     shared_[not_shared[i]-1] = 0;</span>
<span class="lineNum">     257 </span>            :   }
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :   // monte carlo stuff
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   parse(&quot;MC_STEPS&quot;,MCsteps_);</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   parse(&quot;MC_STRIDE&quot;,MCstride_);</span>
<span class="lineNum">     262 </span>            :   // adjust for multiple-time steps
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   MCstride_ *= getStride();</span>
<span class="lineNum">     264 </span>            :   // read bias deposition pace
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   parse(&quot;PACE&quot;, Biaspace_);</span>
<span class="lineNum">     266 </span>            :   // multiply by MCstride
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   Biaspace_ *= MCstride_;</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :   // get temperature
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   double temp=0.0;</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   parse(&quot;TEMP&quot;,temp);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   if(temp&gt;0.0) kbt_=plumed.getAtoms().getKBoltzmann()*temp;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :   else kbt_=plumed.getAtoms().getKbT();</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   checkRead();</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   log.printf(&quot;  temperature of the system in energy unit %f\n&quot;,kbt_);</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   log.printf(&quot;  name of the SELECTOR use for this action %s\n&quot;,selector_.c_str());</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   log.printf(&quot;  number of bins in grid %u\n&quot;,nbin);</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   log.printf(&quot;  number of arguments that will not be rescaled %u\n&quot;,nores_);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   if(nrep_&gt;1) log.printf(&quot;  number of arguments that will not be summed across replicas %u\n&quot;,not_shared.size());</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :   log.printf(&quot;  biasfactor %f\n&quot;,biasf_);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   log.printf(&quot;  initial hills height %f\n&quot;,w0_);</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :   log.printf(&quot;  stride to write bias to file %u\n&quot;,Biasstride_);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   log.printf(&quot;  write bias to file : %s\n&quot;,Biasfilename_.c_str());</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   log.printf(&quot;  number of replicas %u\n&quot;,nrep_);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   log.printf(&quot;  number of MC steps %d\n&quot;,MCsteps_);</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   log.printf(&quot;  do MC every %d steps\n&quot;, MCstride_);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   log.printf(&quot;\n&quot;);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   log &lt;&lt; &quot; Bibliography&quot; &lt;&lt; plumed.cite(&quot;Bonomi, Camilloni, Bioinformatics, 33, 3999 (2017)&quot;) &lt;&lt; &quot;\n&quot;;</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   // add components
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :   addComponent(&quot;igamma&quot;);   componentIsNotPeriodic(&quot;igamma&quot;);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   addComponent(&quot;accgamma&quot;); componentIsNotPeriodic(&quot;accgamma&quot;);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   addComponent(&quot;wtbias&quot;);   componentIsNotPeriodic(&quot;wtbias&quot;);</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   // initialize random seed
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   srand (time(NULL));</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :   // read bias if restarting
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :   if(getRestart()) read_bias();</span>
<a name="304"><span class="lineNum">     304 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineNoCov">          0 : Rescale::~Rescale()</span>
<span class="lineNum">     307 </span>            : {
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :   Biasfile_.close();</span>
<a name="309"><span class="lineNum">     309 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineNoCov">          0 : void Rescale::read_bias()</span>
<span class="lineNum">     312 </span>            : {
<span class="lineNum">     313 </span>            : // open file
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :   IFile *ifile = new IFile();</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   ifile-&gt;link(*this);</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   if(ifile-&gt;FileExist(Biasfilename_)) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     ifile-&gt;open(Biasfilename_);</span>
<span class="lineNum">     318 </span>            :     // read all the lines, store last value of bias
<span class="lineNum">     319 </span>            :     double MDtime;
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :     while(ifile-&gt;scanField(&quot;MD_time&quot;,MDtime)) {</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :       for(unsigned i=0; i&lt;bias_.size(); ++i) {</span>
<span class="lineNum">     322 </span>            :         // convert i to string
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         stringstream ss;</span>
<span class="lineNum">     324 </span>            :         ss &lt;&lt; i;
<span class="lineNum">     325 </span>            :         // label
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :         string label = &quot;b&quot; + ss.str();</span>
<span class="lineNum">     327 </span>            :         // read entry
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         ifile-&gt;scanField(label, bias_[i]);</span>
<span class="lineNum">     329 </span>            :       }
<span class="lineNum">     330 </span>            :       // new line
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :       ifile-&gt;scanField();</span>
<span class="lineNum">     332 </span>            :     }
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     ifile-&gt;close();</span>
<span class="lineNum">     334 </span>            :   } else {
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     error(&quot;Cannot find bias file &quot;+Biasfilename_+&quot;\n&quot;);</span>
<span class="lineNum">     336 </span>            :   }
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   delete ifile;</span>
<a name="338"><span class="lineNum">     338 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineNoCov">          0 : unsigned Rescale::proposeMove(unsigned x, unsigned xmin, unsigned xmax)</span>
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   int xmin_i = static_cast&lt;int&gt;(xmin);</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :   int xmax_i = static_cast&lt;int&gt;(xmax);</span>
<span class="lineNum">     344 </span>            :   int dx;
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   int r = rand() % 2;</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   if( r % 2 == 0 ) dx = +1;</span>
<span class="lineNum">     347 </span>            :   else             dx = -1;
<span class="lineNum">     348 </span>            : // new index, integer
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   int x_new = static_cast&lt;int&gt;(x) + dx;</span>
<span class="lineNum">     350 </span>            : // check boundaries
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   if(x_new &gt;= xmax_i) x_new = xmax_i-1;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   if(x_new &lt;  xmin_i) x_new = xmin_i;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   return static_cast&lt;unsigned&gt;(x_new);</span>
<a name="354"><span class="lineNum">     354 </span>            : }</a>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineNoCov">          0 : bool Rescale::doAccept(double oldE, double newE)</span>
<span class="lineNum">     357 </span>            : {
<span class="lineNum">     358 </span>            :   bool accept = false;
<span class="lineNum">     359 </span>            :   // calculate delta energy
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   double delta = ( newE - oldE ) / kbt_;</span>
<span class="lineNum">     361 </span>            :   // if delta is negative always accept move
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   if( delta &lt; 0.0 ) {</span>
<span class="lineNum">     363 </span>            :     accept = true;
<span class="lineNum">     364 </span>            :   } else {
<span class="lineNum">     365 </span>            :     // otherwise extract random number
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     double s = static_cast&lt;double&gt;(rand()) / RAND_MAX;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     if( s &lt; exp(-delta) ) { accept = true; }</span>
<span class="lineNum">     368 </span>            :   }
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   return accept;</span>
<a name="370"><span class="lineNum">     370 </span>            : }</a>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : void Rescale::doMonteCarlo(unsigned igamma, double oldE,</span>
<span class="lineNum">     373 </span>            :                            vector&lt;double&gt; args, vector&lt;double&gt; bargs)
<span class="lineNum">     374 </span>            : {
<span class="lineNum">     375 </span>            :   double oldB, newB;
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : // cycle on MC steps
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;MCsteps_; ++i) {</span>
<span class="lineNum">     379 </span>            :     // propose move in igamma
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     unsigned new_igamma = proposeMove(igamma, 0, gamma_.size());</span>
<span class="lineNum">     381 </span>            :     // calculate new energy
<span class="lineNum">     382 </span>            :     double newE = 0.0;
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     for(unsigned j=0; j&lt;args.size(); ++j) {</span>
<span class="lineNum">     384 </span>            :       // calculate energy term
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :       double fact = 1.0/pow(gamma_[new_igamma], expo_[j]) - 1.0;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :       newE += args[j] * fact;</span>
<span class="lineNum">     387 </span>            :     }
<span class="lineNum">     388 </span>            :     // calculate contributions from non-rescaled terms
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     if(bargs.size()&gt;0) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :       oldB = bias_[igamma]+bargs[igamma];</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :       newB = bias_[new_igamma]+bargs[new_igamma];</span>
<span class="lineNum">     392 </span>            :     } else {
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :       oldB = bias_[igamma];</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :       newB = bias_[new_igamma];</span>
<span class="lineNum">     395 </span>            :     }
<span class="lineNum">     396 </span>            :     // accept or reject
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     bool accept = doAccept(oldE+oldB, newE+newB);</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :     if(accept) {</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :       igamma = new_igamma;</span>
<span class="lineNum">     400 </span>            :       oldE = newE;
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :       MCaccgamma_++;</span>
<span class="lineNum">     402 </span>            :     }
<span class="lineNum">     403 </span>            :   }
<span class="lineNum">     404 </span>            : // send values of gamma to all replicas
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   if(comm.Get_rank()==0) {</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :     if(multi_sim_comm.Get_rank()!=0) igamma = 0;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :     multi_sim_comm.Sum(&amp;igamma, 1);</span>
<span class="lineNum">     408 </span>            :   } else {
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :     igamma = 0;</span>
<span class="lineNum">     410 </span>            :   }
<span class="lineNum">     411 </span>            : // local communication
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :   comm.Sum(&amp;igamma, 1);</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : // set the value of gamma into passMap
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   plumed.passMap[selector_]=static_cast&lt;double&gt;(igamma);</span>
<a name="416"><span class="lineNum">     416 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 : void Rescale::print_bias(long int step)</span>
<span class="lineNum">     419 </span>            : {
<span class="lineNum">     420 </span>            : // if first time open the file
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :   if(first_bias_) {</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :     first_bias_ = false;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :     Biasfile_.link(*this);</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :     Biasfile_.open(Biasfilename_);</span>
<span class="lineNum">     425 </span>            :     Biasfile_.setHeavyFlush();
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :     Biasfile_.fmtField(&quot;%30.5f&quot;);</span>
<span class="lineNum">     427 </span>            :   }
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            : // write fields
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   double MDtime = static_cast&lt;double&gt;(step)*getTimeStep();</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   Biasfile_.printField(&quot;MD_time&quot;, MDtime);</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;bias_.size(); ++i) {</span>
<span class="lineNum">     433 </span>            :     // convert i to string
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     stringstream ss;</span>
<span class="lineNum">     435 </span>            :     ss &lt;&lt; i;
<span class="lineNum">     436 </span>            :     // label
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     string label = &quot;b&quot; + ss.str();</span>
<span class="lineNum">     438 </span>            :     // print entry
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     Biasfile_.printField(label, bias_[i]);</span>
<span class="lineNum">     440 </span>            :   }
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   Biasfile_.printField();</span>
<a name="442"><span class="lineNum">     442 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineNoCov">          0 : void Rescale::calculate()</span>
<span class="lineNum">     445 </span>            : {
<span class="lineNum">     446 </span>            :   // get the current value of the selector
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   unsigned igamma = static_cast&lt;unsigned&gt;(plumed.passMap[selector_]);</span>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            :   // collect data from other replicas
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   vector&lt;double&gt; all_args(getNumberOfArguments(), 0.0);</span>
<span class="lineNum">     451 </span>            :   // first calculate arguments
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;all_args.size(); ++i) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     double arg = getArgument(i);</span>
<span class="lineNum">     454 </span>            :     // sum shared arguments across replicas
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     if(shared_[i]==1) {</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :       if(comm.Get_rank()==0) multi_sim_comm.Sum(arg);</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :       else                   arg = 0.0;</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :       if(comm.Get_size()&gt;1)  comm.Sum(arg);</span>
<span class="lineNum">     459 </span>            :     }
<span class="lineNum">     460 </span>            :     // put into all_args
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     all_args[i] = arg;</span>
<span class="lineNum">     462 </span>            :   }
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :   // now separate terms that should be rescaled
<span class="lineNum">     465 </span>            :   vector&lt;double&gt; args;
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   if(getNumberOfArguments()-nores_&gt;0) args.resize(getNumberOfArguments()-nores_);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;args.size(); ++i)  args[i]  = all_args[i];</span>
<span class="lineNum">     468 </span>            :   // and terms that should not
<span class="lineNum">     469 </span>            :   vector&lt;double&gt; bargs;
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   if(nores_&gt;0) bargs.resize(nores_);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;bargs.size(); ++i) bargs[i] = all_args[i+args.size()];</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :   // calculate energy and forces, only on rescaled terms
<span class="lineNum">     474 </span>            :   double ene = 0.0;
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;args.size(); ++i) {</span>
<span class="lineNum">     476 </span>            :     // calculate energy term
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     double fact = 1.0/pow(gamma_[igamma], expo_[i]) - 1.0;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     ene += args[i] * fact;</span>
<span class="lineNum">     479 </span>            :     // add force
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     setOutputForce(i, -fact);</span>
<span class="lineNum">     481 </span>            :   }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :   // set to zero on the others
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   for(unsigned i=0; i&lt;bargs.size(); ++i) setOutputForce(i+args.size(), 0.0);</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   // set value of the bias
<span class="lineNum">     487 </span>            :   setBias(ene);
<span class="lineNum">     488 </span>            :   // set value of the wt-bias
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   getPntrToComponent(&quot;wtbias&quot;)-&gt;set(bias_[igamma]);</span>
<span class="lineNum">     490 </span>            :   // set values of gamma
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   getPntrToComponent(&quot;igamma&quot;)-&gt;set(igamma);</span>
<span class="lineNum">     492 </span>            :   // get time step
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   long int step = getStep();</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   if(MCfirst_==-1) MCfirst_=step;</span>
<span class="lineNum">     495 </span>            :   // calculate gamma acceptance
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :   double MCtrials = std::floor(static_cast&lt;double&gt;(step-MCfirst_) / static_cast&lt;double&gt;(MCstride_))+1.0;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   double accgamma = static_cast&lt;double&gt;(MCaccgamma_) / static_cast&lt;double&gt;(MCsteps_) / MCtrials;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   getPntrToComponent(&quot;accgamma&quot;)-&gt;set(accgamma);</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   // do MC at the right time step
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   if(step%MCstride_==0&amp;&amp;!getExchangeStep()) doMonteCarlo(igamma, ene, args, bargs);</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :   // add well-tempered like bias
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :   if(step%Biaspace_==0) {</span>
<span class="lineNum">     505 </span>            :     // get updated igamma
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     unsigned igamma = static_cast&lt;unsigned&gt;(plumed.passMap[selector_]);</span>
<span class="lineNum">     507 </span>            :     // add &quot;Gaussian&quot;
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :     double kbDT = kbt_ * ( biasf_ - 1.0 );</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     bias_[igamma] += w0_ * exp(-bias_[igamma] / kbDT);</span>
<span class="lineNum">     510 </span>            :   }
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :   // print bias
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   if(step%Biasstride_==0) print_bias(step);</span>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     516 </span>            : 
<a name="517"><span class="lineNum">     517 </span>            : </a>
<span class="lineNum">     518 </span>            : }
<span class="lineNum">     519 </span><span class="lineCov">       4839 : }</span>
<span class="lineNum">     520 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
